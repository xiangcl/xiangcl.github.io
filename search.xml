<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[关于登录Linux出现 bash4.2$ 的问题]]></title>
      <url>linux-collection%2Flinux-problem-four.html</url>
      <content type="text"><![CDATA[问题创建用户时出现bash-4.2$ 如图所示 环境 问题分析通过useradd方式创建新用户时，都会将所有的配置文件从/etc/skel到/home目录的新用户录下。但现在没有创建默认的文件。 解决方案 root远程登录 手动创建xiangcl的家目录`# mkdir /home/xiangcl # chown xiangcl:xiangcl /home/xiangcl # chmod 700 /home/xiangcl` 将/etc/skel这个目录的文件复制到/home/xiangcl中` # cd /etc/skel/ # ls -a . .. .bash_logout .bash_profile .bashrc .mozilla # cp .bash_logout /home/xiangcl/ # cp .bash_profile /home/xiangcl/ # cp .bashrc /home/xiangcl`]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决linux：vim的退格删除键不能用]]></title>
      <url>linux%2Fvim-problem-two.html</url>
      <content type="text"><![CDATA[问题：linux下vim的退格删除键不能使用解决方案:~/.vimrc中加入set backspace=indent,eol,start即可，测试时需要注销重新登录 或者进入vim后执行:set backspace=indent,eol,start可直接生效 摘自:http://blog.zhukunqian.com/?p=314 对作者表示感谢，如有侵权，请联系删除。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决：sudo useradd xxx`时，出现`xxx is not in the sudoers file. This incident will be reported.]]></title>
      <url>linux-collection%2Flinux-problem-one.html</url>
      <content type="text"><![CDATA[问题描述使用sudo useradd xxx时，出现xxx is not in the sudoers file. This incident will be reported. 如图所示 当前环境 问题分析用户没有加入到sudo的配置文件里，可以通过编辑sudoers文件，来解决这个问题。 解决方案 切换到root用户 添加sudo文件的写权限 chmod u+w /etc/sudoers 编辑sudoers文件 vim /etc/sudoers 找到 root ALL=(ALL) ALL,在他下面添加xxx ALL=(ALL) ALL (这里的xxx是你的用户名)youuser ALL=(ALL) ALL youuser ALL=(ALL) ALL youuser ALL=(ALL) NOPASSWD: ALL youuser ALL=(ALL) NOPASSWD: ALL 第一行:允许用户youuser执行sudo命令(需要输入密码). 第二行:允许用户组youuser里面的用户执行sudo命令(需要输入密码). 第三行:允许用户youuser执行sudo命令,并且在执行的时候不输入密码. 第四行:允许用户组youuser里面的用户执行sudo命令,并且在执行的时候不输入密码. 撤销sudoers的文件的写权限chmod u-w /etc/sudoers]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决Centos7初次开机提示Initial setup of CentOS Linux 7 (core)]]></title>
      <url>linux-collection%2Flinux-problem-three.html</url>
      <content type="text"><![CDATA[安装完成centos7后出现如下提示：Initial setup of CentOS Linux 7 (core) 1) [x] Creat user 2) [!] License information (no user will be created) (license not accepted) Please make your choice from above [&apos;q&apos; to quit | &apos;c&apos; to continue | &apos;r&apos; to refresh]: 解决方案： 输入【1】，按Enter键阅读许可协议， 输入【2】，按Enter键接受许可协议， 输入【q】，按Enter键退出， 输入【yes】，按Enter键确定， 重启之后即可进入图形登录界面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图解OS及Linux的基础知识]]></title>
      <url>linux%2Fchart-linux-os.html</url>
      <content type="text"><![CDATA[试着尽量用图示来表示个人对内容的理解，不足之处，还望不吝指教。 一.CPU 1.cpu与指令集 CPU分为运算器和控制器 CPU指令 特权指令 拥有管理权限，（一般情况下，只有OS才有权限运行特权指令） 普通指令 拥有普通功能，一般应用程序运行 不同的运算由不同的运算器完成运算（由指令集提供运算） 程序员：一般面向操作系统编程 图示说明： 2.人与机器 感觉没什么好解释的，一切尽在图中 图示说明 二.OS 1.OS的目的与功能 OS：Operating System System Call 简称为：Syscall （系统调用） OS的通用目的与功能： 图示说明： 2.编程的层次 硬件规格：hardware specifiacation 不同厂商的硬件规格千差万别，API也各不相同，写起来极为不便； 系统调用：数量很少，但是很精巧； 库调用：library call 把底层的功能整合出来，提供成离最终目标更近的功能；对所有的计算机功能来说，所有的功能都是通过调用实现；（通常都是c，c++库） 图示说明： 3.指令环 由内到外依次是环0、环1、环2、环3； 环0是特权指令，一般只有操作系统有权限运行； 环1、环2出于历史原因，没有使用； 环3是普通指令，一般应用程序使用； 特殊情况：例如：mkdir /home/test Note：没办法直接完成，需要向内核申请权限； 图示说明： 4.程序的运行模式 用户空间：user space（us） 内核空间：system space 图示说明： 三.UI：User Interface 对OS来说：UI是用户接口、对用户来说UI是前端； GUI：Graphic User Interface （图形用户接口） CLI：Command Line Interface （命令行接口） 图示说明： 四.ABI与API ABI：Application Binary Interface（应用程序二进制接口） 描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。 API: Application Programming Interface（应用程序编程接口） 是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节 图示说明： 五.主流的CPU架构 图示说明： 六.流行的OS分支 图示说明：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SEO的简单优化]]></title>
      <url>seo%2Fsimple-seo-optimization.html</url>
      <content type="text"><![CDATA[SEO优化SEO (Search Engine Optimization) (搜索引擎优化)分类： 白帽SEO 黑帽SEO 白帽SEO内容上的SEO： 网站标题、关键字、描述 网站内容优化 Robot.txt文件 网站地图 增加外链接引用 作为前端工程师的优化方法： 网站结构布局优化 网页代码优化 前端工程师与SEO 网站结构布局优化 扁平化结构 控制首页链接数量 扁平化的目录层次 导航SEO优化 面包屑导航 让用户了解当前所处位置 是用户可以了解网站组织形式 不可忽略的细节 logo及导航条 控制页面的大小 网页代码优化 &lt;title&gt;标题 &lt;meta keywords&gt;关键词 &lt;meta description&gt;网页描述 语义化代码 &lt;h1&gt;~&lt;h6&gt;标签多用于标题 &lt;ul&gt;标签多用于无序列表 &lt;ol&gt;标签多用于有序列表 &lt;dl&gt;标签多用于定数据列表 &lt;em&gt;,&lt;strong&gt;表示强调 标签的优化 &lt;a&gt;标签 rel=&quot;nofollow&quot; 是一个HTML标签的属性值。这个标签的意义是告诉搜索引擎”不要追踪此网页上的链接”或”不要追踪此特定链接。 &lt;h1&gt; 正文标题，搜索引擎喜欢h1标签。样式用css修改。 &lt;p&gt; and &lt;br&gt; &lt;p&gt;标签仅仅用于段落&lt;br&gt;仅仅用于文本标签的换行 &lt;caption&gt; 表格标题用&lt;caption&gt;定义 &lt;img&gt; 应加上&lt;alt&gt; &lt;strong&gt;&lt;em&gt;与&lt;b&gt;&lt;i&gt; &lt;strong&gt;的权重高于&lt;em&gt;，&lt;strong&gt;、&lt;em&gt;更讨搜索引擎喜欢 小贴士 重要内容HTML代码放在最前面。(主要代码优先读取) 重要内容不要用JS输出 尽量使用iframe框架 谨慎使用display:none; 不断精简代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[了解GitHub]]></title>
      <url>tool-config%2Fknow-github.html</url>
      <content type="text"><![CDATA[什么是GitHub？github是为开发者提供git仓库的托管服务。是一个让开发者与朋友、同事、同学及陌生人共享代码的完美场所。 github总部：美国旧金山吉祥物：octocat 并不只是git仓库的托管服务GitHub 除提供 Git 仓库的托管服务外，还为开发者或团队提供了一系列功能，帮助其高效率、高品质地进行代码编写。 git与github的区别？在 Git 中，开发者将源代码存入名叫“Git 仓库”的资料库中并加以使用。而GitHub则是在网络上提供 Git 仓库的一项服务。 也就是说，GitHub 上公开的软件源代码全都由 Git 进行管理。理解 Git，是熟练运用 GitHub 的关键所在。 使用github会带来哪些变化？协作形式变化Pull RequestPull Request 是指开发者在本地对源代码进行更改后，向 GitHub 中托管的 Git 仓库请求合并的功能。 对特定用户进行评论如果想让特定用户来看，只要用“ @ 用户名”的格式书写，对方便会接到通知（Notifications），查看 Issue。由于也提供了 Wiki 功能，开发者可以轻松创建文档，进行公开、共享。Wiki更新的历史记录也在Git中管理，可以让用户轻松更改。 GitHub Flavored Markdown在GitHub上，用户所有用文字输入的功能都可以用 GitHub Flavored Markdown（GFM）语法进行描述。这个语法可以让标记变得简单，以此写出的评论与文档也会更容易理解。 随着 GitHub 的普及，正在有越来越多的服务开始兼容 Markdown语法。 GitHub提供的主要功能Git仓库一般情况下，我们可以免费建立任意个GitHub提供的Git仓库。但如果需要建立只对特定人物或只对自己公开的私有仓库，则需要付费使用。 Organization通常来说，个人使用时只要使用个人账户就足够了，但如果是公司，建议使用 Organization 账户。它的优点在于可以统一管理账户和权限，还能统一支付一些费用。 如果只使用公开仓库，是可以免费创建 Organization 账户的。 lssueIssue 功能，是将一个任务或问题分配给一个 Issue 进行追踪和管理的功能。 Wiki通过 Wiki 功能，任何人都能随时对一篇文章进行更改并保存，因此可以多人共同完成一篇文章。该功能常用在开发文档或手册的编写中。语法方面，可以通过GFM语法进行书写。 Wiki 页也是作为Git仓库进行管理的，改版的历史记录会被切实保存下来，使用者可以放心改写。由于其支持克隆至本地进行编辑，所以程序员使用时可以不必开启浏览器。 Pull Request开发者向GitHub的仓库推送更改或功能添加后，可通过Pull Request功能向别人的仓库提出申请，请求对方合并。 Pull Request送出后，目标仓库的管理员等人将能够查看Pull Request的内容及其中包含的代码更改。 同时，GitHub还提供了对Pull Request和源代码前后差别进行讨论的功能。通过此功能，可以以行为当位对源代码添加评论，让程序员之间更高效的交流。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[了解Git]]></title>
      <url>tool-config%2Fknow-git.html</url>
      <content type="text"><![CDATA[git历史git属于分散型版本管理系统，是为版本管理而设计的软件。 众所周知，Linux内核开源项目有着为数众广的参与者。绝大多数的Linux内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991-2002)。 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断的发展，已经成为了最大的服务器系统软件。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的？ 实事是，在2002年以前，世界各地的志愿者把源代码文件通过diff方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。 开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持（允许上千个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） 最后实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以感受一下。 以上故事来自Git诞生背后的一些故事 什么是版本控制？版本管理就是管理更新的历史记录。它为我们提供了一些在软件开发过程中必不可少的功能，例如记录一款软件添加或更改源代码的过程，回滚到特定阶段，恢复误删除的文件等。 集中型与分散型集中型代表：Subversion 图示： 将仓库集中存放在服务器之中，所以只存在一个仓库。 优点： 便于管理 缺点： 环境限制 服务器宕机的危险 服务器故障可能导致数据丢失 分散型图示： GitHub 将仓库 Fork 给了每一个用户。 Fork 就是将 GitHub 的某个特定仓库复制到自己的账户下。 Fork 出的仓库与原仓库是两个不同的仓库，开发者可以随意编辑。 优点： 不比需要远程链接仓库 便于开发者沟通 缺点： 流程复杂 学习成本相对较高 安装$ sudo yum isntall git 初始设置设置姓名和邮箱地址$ git config --global user.name &quot;Firstname Lastname&quot; $ git config --global user.email &quot;your_email@example.com&quot; 这个命令，会在“ ~/.gitconfig”中以如下形式输出设置文件 [user] name = Firstname Lastname email = your_email@example.com 这里设置的姓名和邮箱地址会用在 Git 的提交日志中。由于在 GitHub 上公开仓库时，这里的姓名和邮箱地址也会随着提交日志一同被公开。 提高命令输出的可读性顺便一提，将 color.ui 设置为 auto 可以让命令的输出拥有更高的可读性。 $ git config --global color.ui auto “ ~/.gitconfig”中会增加下面一行。 [color] ui = auto 这样一来，各种命令的输出就会变得更容易分辨。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[详解Linux用户和组的权限管理及相关命令]]></title>
      <url>linux%2Flinux-user-groups.html</url>
      <content type="text"><![CDATA[在Linux中，用户和组的权限管理是很基础，也是很至关重要的。本文，对这个知识点做了一次详细的梳理； 一、文件的权限主要针对3类用户定义 owner：属主，简写为：u；group：属组，简写为：g；other：其它，简写为：o； 每个文件针对每类访问者都定义了三种权限： r：Readable：可读 w：Writable：可写 x：eXcutable：可执行 对文件来说以上三种权限的意义： r：可使用文件查看类工具获取其内容； w：可修改其内容； x：可以把此文件提请内核启动为一个进程； 对目录来说，以上三种权限的意义： r：可以使用ls查看此目录文件中的列表； w：可在此目录中创建文件，也可删除此目录中的文件； x：可以使用ls -l查看此目录中文件列表，可以cd进入此目录； - - - 000 0 - - x 001 1 - w - 010 2 - w x 011 3 r - - 100 4 r - x 101 5 r w - 110 6 r w x 111 7 从上图可以看出： r : 4 w : 2 x : 1 例如： 640：rw-r—– 755：rwxr-xr-x 二、修改用户权限 chmod [OPTION]… MODE[,MODE]… FILE…chmod [OPTION]… OCTAL-MODE FILE…chmod [OPTION]… –reference=RFILE FILE… 1.chmod [OPTION]… OCTAL-MODE FILE… -R:递归修改权限 实际示例： 2.chmod [OPTION]… MODE[,MODE]… FILE… MODE：修改一类用户的所有权限： u=# g=# o=# ug=# a=# u=#,g=# Note：#代表你所需要改的权限 实际示例： MODE:修改一类用户的某位或某些权限： u+# u-# g+# g-# o+# o-# gu+# Note：#表示某位或某些权限实际示例： 3.chmod [OPTION]… –reference=RFILE FILE… 参考RFILE文件的权限，将FILE的修改为同RFILE一样的权限； 图片示例： 4.修改文件属主和属组： 仅root可用 修改文件的属主：chown chown [OPTION]… [OWNER][:[GROUP]] FILE… 用法： OWNER：仅修改属主 OWNER:GROUP：修改属主和属组 :GROUP：仅修改属组 Note：命令中的：可用 . 号替换； -R：递归 实际示例： chown [OPTION]… –reference=RFILE FILE… 同上面chmod的用发一样 5.修改文件属组：chgrp chgrp [OPTION]… GROUP FILE… chgrp [OPTION]… –reference=RFILE FILE… -R：递归 实际示例： 6.文件或目录创建时的遮罩码：umask FILE：666-umask Note：如果某类的用户的权限减得的结果中存在x权限，则将其权限+1 DIR：777-umask umask：查看 umask+#：设定 Note：仅对当前用户的当前shell进程有效； 实际示例：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux文件与目录管理1]]></title>
      <url>Linux%2Flinux-file-dir-man-one.html</url>
      <content type="text"><![CDATA[一、目录与路径相对路径与绝对路径1.绝对路径：路径的写法“一定由跟目录 / 写起” 例如：/usr/share/doc 2.相对路径：路径的写法“不是由/写起” 例如：由 /usr/share/doc 要到 /usr/share/man 下面时，可以写成： “cd ../man”这就是相对路径的写法啦！相对路径意指“相对于目前工作目录的路径！” 目录的相关操作特殊目录12345dr-xr-xr-x. 19 root root 4096 11月 5 10:25 . #代表此层目录dr-xr-xr-x. 19 root root 4096 11月 5 10:25 .. #代表上一层目录~ #代表“目前使用者身份”所在的主文件夹~xiangcl #代表 xiangcl 这个使用者的主文件夹（ xiangcl是个帐号名称） 常见的目录处理指令cd (change directory, 变换目录)1234567$ cd ~ #回到当前用户的主目录$ cd ~USERNAME #切换到指定用户目录的主目录$ cd #回到当前用户的主目录$ cd .. #切换到当前位置的上一层目录$ cd - #在上一个目录和当前目录之间来回切换$ cd /usr/share #进入/usr/share这个目录，绝对路径的写法$ cd ../src #进入/usr/src这个目录，相对路径的写法 pwd [OPTION] （显示目前所在的目录）1234567891011$ pwd #显示当前所在目录的绝对路径$ pwd -P #显示出真实路径，而非链接(link)路径例如：[xiangcl@VM_0_26_centos ~]$ cd /var/mail/ #切换到/var/mail这个目录下[xiangcl@VM_0_26_centos mail]$ pwd/var/mail #列出当前目录的绝对路径[xiangcl@VM_0_26_centos mail]$ pwd -P/var/spool/mail #感觉和没加-P的差别有点大[xiangcl@VM_0_26_centos mail]$ cd ..[xiangcl@VM_0_26_centos var]$ ls -l maillrwxrwxrwx 1 root root 10 11月 1 09:52 mail -&gt; spool/mail #原来/var/mail 是链接文件，链接到 /var/spool/mail pwd是Print Working Directory的缩写，是显示目前所在目录的指令。 mkdir [options] file… (创建新目录)1234567891011121314151617181920212223242526-m mode, --mode=mode 设置文件的权限喔！直接设置，不需要看默认权限 （ umask）-p, --parents 帮助你直接将所需要的目录（包含上层目录） 递回创建起来！-v 显示详细信息[xiangcl@VM_0_26_centos ~]$ cd /tmp/ #切换到/tpm下去做实验[xiangcl@VM_0_26_centos tmp]$ mkdir test #创建test这个目录，没有返回消息代表创建成功[xiangcl@VM_0_26_centos tmp]$ mkdir test1/test2/test3 #创建失败mkdir: 无法创建目录&quot;test1/test2/test3&quot;: 没有那个文件或目录[xiangcl@VM_0_26_centos tmp]$ mkdir -p test1/test2/test3 #需要加上-p去递归创建[xiangcl@VM_0_26_centos tmp]$ tree test1 #显示test1这个目录下的层级结构test1`-- test2 `-- test32 directories, 0 files[xiangcl@VM_0_26_centos tmp]$ mkdir -m 711 test2[xiangcl@VM_0_26_centos tmp]$ ls -ld test*drwxrwxr-x 2 xiangcl xiangcl 4096 11月 5 11:32 testdrwxrwxr-x 3 xiangcl xiangcl 4096 11月 5 11:33 test1drwx--x--x 2 xiangcl xiangcl 4096 11月 5 11:37 test2#没有加-m选项的目录会使用系统默认的属性#[umask]设置默认属性 rmdir （删除“空”目录）123456789101112131415161718rmdir[options]directory...OPTION: -v：显示过程[xiangcl@VM_0_26_centos tmp]$ ls -ld test* #查看/tmp这个目录下的文件drwxrwxr-x 2 xiangcl xiangcl 4096 11月 5 11:32 testdrwxrwxr-x 3 xiangcl xiangcl 4096 11月 5 11:33 test1drwx--x--x 2 xiangcl xiangcl 4096 11月 5 11:37 test2drwxr--r-- 2 xiangcl root 4096 11月 1 13:44 testing[xiangcl@VM_0_26_centos tmp]$ rmdir test #删除test这个目录，Note：test这个目录为空[xiangcl@VM_0_26_centos tmp]$ rmdir test1 #删除test1这个目录失败，因为这个目录不为空rmdir: 删除 &quot;test1&quot; 失败: 目录非空[xiangcl@VM_0_26_centos tmp]$ rmdir -p test1/test2/test3/ #加上那个-p选项[xiangcl@VM_0_26_centos tmp]$ ls -ld test*drwx--x--x 2 xiangcl xiangcl 4096 11月 5 11:37 test2drwxr--r-- 2 xiangcl root 4096 11月 1 13:44 testing 文件内容类型查看命令：file123456file /PAHT/TO/SOMEWHERE范例：查看 /etc/passwd 的文件类型[xiangcl@VM_0_26_centos tmp]$ cd /etc/[xiangcl@VM_0_26_centos etc]$ file ./passwd./passwd: ASCII text 回显命令：echo1234567-n: 禁止自动添加换行符号；-e: 允许使用转义符； \n: 换行 \t: 制表符echo &quot;$VAR_NAME&quot;: 变量会替换，双引号表弱引用echo &apos;$VAR_NAME&apos;: 变量不会替换，强引用 which：显示命令对应的程序文件路径1234567891011which [OPTION] COMMAND --skip-alias：禁止显示别名范例一：显示 ls 对应的程序文件路径[xiangcl@VM_0_26_centos tmp]$ which lsalias ls=&apos;ls --color=auto&apos; /usr/bin/ls范例二：在范例一的基础上不显示别名[xiangcl@VM_0_26_centos tmp]$ which --skip-alias ls/usr/bin/ls whatis :用于查询一个命令执行什么功能，并将查询结果打印到终端上1234567使用mkwhatis命令可将当前系统上所有的帮助手册及与之对应的关键字创建为一个数据库；whatis命令在用catman命令创建的数据库中查找command参数指定的命令、系统调用、库函数或特殊文件名。whatis命令显示手册部分的页眉行。然后可以发出man命令以获取附加的信息。whatis命令等同于使用man -f命令。（需要root权限）范例：显示 ls 手册部分的页眉行[root@VM_0_26_centos ~]# whatis lsls (1) - 列目录内容 二、文件与目录管理ls [options] [files…] （列出目录的内容）12345678910111213141516171819202122232425262728293031323334353637-a，--all 全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（ 常用）-A，--almost-all 全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录-d，--directory 仅列出目录本身，而不是列出目录内的文件数据-f 直接列出结果，而不进行排序 （ ls 默认会以文件名排序！）-F 根据文件、目录等信息，给予附加数据结构 例如：*:代表可可执行文件； /:代表目录； =:代表 socket 文件； &amp;#124;:代表 FIFO 文件；-h，--human-readable 将文件大小以人类较易读的方式（ 例如 GB, KB 等等） 列出来；-i 列出 inode 号码，inode 的意义下一章将会介绍；-l，, --format=long, --format=verbose 长数据串行出，除每个文件名外，增加显示文件类型、权限、硬链接数、所有者名、组名、大小（byte）、及时间信息（如未指明是其它时间即指修改时间）。对于6个月以上的文件或超出未来1小时的文件，时间信息中的时分将被年代取代。；（ 常用）-n，--numeric-uid-gid 列出 UID 与 GID 而非使用者与群组的名称 （ UID与GID会在帐号管理提到！）-r，--reverse 将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；-R，--recursive 连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；-S，--sort=size 以文件大小大小排序，而不是用文件名排序；-t，--sort=time 依时间排序，而不是用文件名。--color=never 不要依据文件特性给予颜色显示；--color=always 显示颜色--color=auto 让系统自行依据设置来判断是否给予颜色--full-time 以完整时间模式（包含年、月、日、时、分）输出--time=&#123;atime,ctime&#125; 输出 access 时间或改变权限属性时间（ctime），而非内容变更时间（modification time） 复制(cp)、删除(rm)与移动(mv)cp (复制文件或目录)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758cp [OPTION]... [-T] SOURCE DESTcp [OPTION]... SOURCE... DIRECTORYcp [OPTION]... -t DIRECTORY SOURCE...cp SRC DEST SRC是文件： 如果目标不存在：新建DEST，并将SRC中内容填充至DEST中； 如果目录存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中； 此时建议为cp命令使用-i选项； 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填充至新文件中；cp SRC DEST SRC是目录： 此时使用选项：-r 如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中； 如果DEST存在： 如果DEST是文件：报错 如果DEST是目录：在DEST下新建与源目录同名的目录及文件，将SRC中的文件内容填充至新目录的文件中。cp SRC... DEST SRC...：多个文件 DEST必须存在，且为目录，其它情形均会出错；Common options:-a,--archive 归档，相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明；（ 常用）-d, --no-dereference --preserv=links --preserv[=ATTR_LIST] mode: 权限 ownership: 属主属组 timestamp: links xattr context all 复制符号链接作为符号链接而不是复制它指向的文件,并且保护在副本中原文件之间的硬链接.-f,--force 为强制（ force） 的意思，若目标文件已经存在且无法打开，则移除后再尝试一次；-i,--interactive 交互式 若目标文件（ destination） 已经存在时，在覆盖时会先询问动作的进行（ 常用）-l,--link 进行硬式链接（ hard link） 的链接文件创建，而非复制文件本身；-p,--preserve 连同文件的属性（权限、用户、时间、许可）一起复制过去，而非使用默认属性（ 备份常用） ；-r 递回持续复制，用于目录的复制行为；（ 常用）-R, --recursive 递归地复制目录,保留非目录-s，--symbolic-link 复制成为符号链接文件 （ symbolic link） ，亦即“捷径”文件；-u，--update destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。--preserve=all 除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。 最后需要注意的，如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！ rm (移除文件或目录)12345678910111213141516171819202122232425262728293031323334353637383940414243rm [optiongs] files...options: -f, --force 强制删除，就是 force 的意识，忽略不存在的文件，不会出现警告讯息； -i, --interactive 交互式 互动模式，在删除前会询问使用者是否删除这一动作； -r, -R，--recursive 递归删除，最常用在目录的删除。 -v，--verbose 在移除每个文件之前打印其名称。范例一：将创建的文件删除[xiangcl@VM_0_26_centos tmp]$ touch test[xiangcl@VM_0_26_centos tmp]$ rm -i testrm：是否删除普通空文件 &quot;test&quot;？y# 加上 -i 选项就会主动询问是否删除，避免文件的误删。范例二：通过*，删除所有以test开头的文件[xiangcl@VM_0_26_centos tmp]$ rm -i test*# * 代表删除所有以test开头的文件范例三：将不为空的目录删除[root@VM_0_26_centos tmp]# rmdir ./testingrmdir: 删除 &quot;./testing&quot; 失败: 目录非空[root@VM_0_26_centos tmp]# rm -r ./testingrm：是否进入目录&quot;./testing&quot;? yrm：是否删除普通空文件 &quot;./testing/1.sh&quot;？yrm：是否删除普通空文件 &quot;./testing/2.sh&quot;？yrm：是否删除普通空文件 &quot;./testing/3.sh&quot;？yrm：是否删除目录 &quot;./testing&quot;？y# 因为是root身份，默认已经加入了 -i 的选项，这是一种保护机制范例四：删除一个带有 - 开头的文件[root@VM_0_26_centos tmp]# touch ./-aaa-[root@VM_0_26_centos tmp]# ls -l -rw-r--r-- 1 root root 0 11月 9 14:41 -aaa-[root@VM_0_26_centos tmp]# rm -aaa-rm：无效选项 -- aTry &apos;rm ./-aaa-&apos; to remove the file &quot;-aaa-&quot;.Try &apos;rm --help&apos; for more information.[root@VM_0_26_centos tmp]# rm ./-aaa-rm：是否删除普通空文件 &quot;./-aaa-&quot;？y 小结 为了防止文件被root误杀，很多distributions都默认在 rm 指令中加了 -i 选项； 递归删除使用 -r 选项，但是-r选项威力太过强大，一般只有确定文件要删除才会使用； 文件名最好不要使用 - 开头； mv (移动文件与目录、或用于文件更名)123456789101112131415161718192021222324252627mv [option]... source destinationmv [option]... source... directorymv [option]... --target-directory=DIRECTORY SOURCE...option: -f, --force 强制的意思，如果咪表文件已经存在，不会询问而直接覆盖； -i, --interactive 覆盖提示 -u, --update 若目标文件已经存在，且source比目标文件新，才是更新覆盖；范例一：创建一目录，将文件移动到目录中[root@VM_0_26_centos tmp]# cp ~/.bashrc bashrc[root@VM_0_26_centos tmp]# mkdir test[root@VM_0_26_centos tmp]# mv bashrc test/# 将某个文件移动到目录中范例二：文件更名[root@VM_0_26_centos tmp]# mv test test1# 将 test 更名为 test1；范例三：将多个文件移动到目录中[root@VM_0_26_centos tmp]# cp ~/.bashrc bashrc1[root@VM_0_26_centos tmp]# cp ~/.bashrc bashrc2[root@VM_0_26_centos tmp]# mv bashrc1 bashrc2 test1# 如果有多个源文件或目录，则最后一个目标文件一定是目录； 取得文件名与完整路径的目录12345[root@VM_0_26_centos tmp]# basename /etc/sysconfig/networknetwork[root@VM_0_26_centos tmp]# dirname /etc/sysconfig/network/etc/sysconfig# 取得文件路径对于在shell script中是很重要的； 三、文件内容查看 cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 od 以二进制的方式读取文件内容！ 直接检视文件内容cat (concatenate)12345678910111213141516171819202122232425262728cat [选项列表] [文件列表]...选项： -A, --show-all 相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b, --number-nonblank 列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E, --show-ends 将结尾的断行字符 $ 显示出来； -n, --number 打印出行号，连同空白行也会有行号，与 -b 的选项不同； -T, --show-tabs 将 [tab] 按键以 ^I 显示出来； -v, --show-nonprinting 列出一些看不出来的特殊字符范例一：查看 /etc/issue 这个文件的内容[root@VM_0_26_centos ~]# cat /etc/issue\SKernel \r on an \m范例二：在上一题的基础上加上行号[root@VM_0_26_centos ~]# cat -n /etc/issue #第一种方法 1 \S 2 Kernel \r on an \m 3[root@VM_0_26_centos ~]# cat -b /etc/issue #第二种方法 1 \S 2 Kernel \r on an \m tac (反向列出文本)12345[xiangcl@VM_0_26_centos ~]$ tac /etc/issueKernel \r on an \m\S# 与上面 cat的显示效果相反，是由最后一行开始显示的。 nl - number lines of files (添加行号打印)1234567891011121314151617181920212223242526272829303132333435nl [OPTION]... [FILE]...OPTION:-b, --body-numbering=STYLE ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号（类似 cat -n） ； -b t ：如果有空行，空的那一行不要列出行号（默认值） ；-n, --number-format=FORMAT ：列出行号表示的方法，主要有三种： -n ln ：行号在屏幕的最左方显示； -n rn ：行号在自己字段的最右方显示，且不加 0 ； -n rz ：行号在自己字段的最右方显示，且加 0 ；-w, --number-width=NUMBER ：行号字段的占用的字符数。范例一：用 nl 列出 /etc/issue 的内容[xiangcl@VM_0_26_centos ~]$ nl /etc/issue 1 \S 2 Kernel \r on an \m# 这个文件有三行，第三行为空白(没有任何字符)# 因为他是空白行，所以 nl 不会加上行号，所以如果确定要加上行号，可以这样做：[xiangcl@VM_0_26_centos ~]$ nl -b a /etc/issue 1 \S 2 Kernel \r on an \m 3# 行号加上了，如果要让行号前面自动补上0，可以这样做：[xiangcl@VM_0_26_centos ~]$ nl -b a -n rz /etc/issue000001 \S000002 Kernel \r on an \m000003# 自动在字段的地方补上 0 了，默认字段是六位数，如何改为三位数呢？[xiangcl@VM_0_26_centos ~]$ nl -b a -n rz -w 3 /etc/issue001 \S002 Kernel \r on an \m003 可翻页查看文本前面提到的nl、cat与tac命令，都是一次性将数据一口气显示到屏幕上，接下来介绍一下可翻页显示的指令。 more (在显示器上阅读文件的过滤器)123456789101112131415more [-dlfpcsu] [-num] [+/ pattern] [+ linenum] [file ...]OPTION： -num: 这个选项指定屏幕的行数 (以整数表示). # num不是输入num而是输入数字； -f: 使 more 计数 逻辑行, 而不是 屏幕行 (就是说, 长行 不会 断到 下一行). -d：显示翻页及退出提示[xiangcl@VM_0_26_centos ~]$ more /etc/man_db.conf# 使用这个指令后就会进入阅读模式，那么，怎么操作呢？- 空白键 （space）：代表向下翻一页；- Enter： 代表向下翻“一行”；- / 字串 ：代表在这个显示的内容当中，向下搜寻“字串”这个关键字；- :f： 立刻显示出文件名以及目前显示的行数；- q： 代表立刻离开 more ，不再显示该文件内容。- b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管道无用。 这里特别强调的是搜索这个指令，在 more 的阅读模式下，直接输入 / 后，光标就会跑到最下面一行，并且等待你的输入，你输入需要搜索的字串后并按下[enter]，more就会向下搜索该字符串，向下使用 n 即可。最后按 q 键退出。 less (一页一页翻动)1[xiangcl@VM_0_26_centos ~]$ less /etc/man_db.conf 在 less 查看文件时常用的指令： 空白键： 向下翻动一页； [pagedown]： 向下翻动一页； [pageup]： 向上翻动一页； / 字串： 向下搜寻“字串”的功能； ? 字串： 向上搜寻“字串”的功能； n： 重复前一个搜寻 （与 / 或 ? 有关！） N： 反向的重复前一个搜寻 （与 / 或 ? 有关！） g： 前进到这个数据的第一行去； G： 前进到这个数据的最后一行去（注意大小写） ； q： 离开 less 这个程序； 个人觉得相对于more指令来说less要好用，不过存在即有存在的道理，这其中好处还需诸君自行体会。 数据撷取有的时候，我们仅仅只需要对文件有个了解。而前面所了解到的指令都是将全文输出，下面我们来了解一下怎样对数据进行简单的撷取。取前面几行文本(head)或取后面(tail)几行文文本。 注意：head与tail都是以 行 为当位进行数据的撷取。 head (输出文件开始的部分)12345678910-c # 指定获取前#字节-n #, --lines=NUMBER 显示起始的NUMBER行,而非默认的起始10行-q, --quiet, --silent 不显示包含给定文件名的文件头-v, --verbose 总是显示包含给定文件名的文件头 12345678910111213141516171819202122[xiangcl@VM_0_26_centos ~]$ head /etc/man_db.conf #默认显示前10行### This file is used by the man-db package to configure the man and cat paths.# It is also used to provide a manpath for those without one by examining# their PATH environment variable. For details see the manpath(5) man page.## Lines beginning with `#&apos; are comments and are ignored. Any combination of# tabs or spaces may be used as `whitespace&apos; separators.## There are three mappings allowed in this file:[xiangcl@VM_0_26_centos ~]$ head -n 3 /etc/man_db.conf #可以直接指定要显示的行数### This file is used by the man-db package to configure the man and cat paths.[xiangcl@VM_0_26_centos ~]$ head -n 3 -v /etc/man_db.conf #显示前三行且在开始处显示文件路径==&gt; /etc/man_db.conf &lt;==### This file is used by the man-db package to configure the man and cat paths. 如果 -n 后面接的是负数的话，则仅仅显示前面的行数。例如： CentOS 7.1 的 /etc/mandb.conf 共有131行，则上述的指令head -n -100 /etc/man_db.conf 就会列出前面31行，后面100行不会被打印出来。 tail (输出文件末尾部分)123456789101112131415161718192021-c, --bytes=N 输出最后N个字节-f, --follow[=&#123;name|descriptor&#125;] 当文件增长时,输出后续添加的数据; -f, --follow以及 --follow=descriptor 都是相同的意思-n, --lines=N 输出最后N行,而非默认的最后10行--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束.-q, --quiet, --silent 从不输出给出文件名的首部-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒-v, --verbose 总是输出给出文件名的首部 1234567891011[xiangcl@VM_0_26_centos ~]$ tail /etc/man_db.conf# 默认情况下显示的是最后10行# 如果要显示最后20行，则可以写成：[xiangcl@VM_0_26_centos ~]$ tail -n 20 /etc/man_db.conf范例一 ：如果不知道 /etc/man_db.conf 有多少行，却只想列出100行以后的数据：[xiangcl@VM_0_26_centos ~]$ tail -n +100 /etc/man_db.conf范例二 ：持续侦测 /var/log/messages 的内容[root@VM_0_26_centos ~]# tail -f /var/log/messages# 如果文件内容有变化的话会持续更新，退出请按[Crtl]+c; Note：范例二必须使用root身份才行。* 123456例题一： 显示 /etc/man_db.conf 的第 11 到第 20 行# 思路：先取前20行，再取后10行；$ head -n 20 /etc/man_db.conf | tail -n 10例题二： 显示 /etc/man_db.conf 的第 11 到第 20 行，且带行号$ cat -n /etc/man_db.conf | head -n 20 | tail -n 10 非纯文本文件：od12345678910111213141516171819202122232425od [OPTION]... [FILE]...od [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]od --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.][b]]OPTION: -t, --format=TYPE ：后面可以接各种“类型 （ TYPE） ”的输出，例如： a ：利用默认的字符来输出； c ：使用 ASCII 字符来输出 d[size] ：利用十进制（ decimal） 来输出数据，每个整数占用 size Bytes ； f[size] ：利用浮点数值（ floating） 来输出数据，每个数占用 size Bytes ； o[size] ：利用八进位（ octal） 来输出数据，每个整数占用 size Bytes ； x[size] ：利用十六进制（ hexadecimal） 来输出数据，每个整数占用 size Bytes ；范例一： 将/usr/bin/passwd的内容使用ASCII方式来展现[root@VM_0_26_centos ~]# od -t c /usr/bin/passwd范例二：将/etc/issue这个文件的内容以8进位列出储存值与ASCII的对照表[root@VM_0_26_centos ~]# od -t oCc /etc/issue0000000 134 123 012 113 145 162 156 145 154 040 134 162 040 157 156 040 \ S \n K e r n e l \ r o n0000020 141 156 040 134 155 012 012 a n \ m \n \n0000027# 如上所示，可以发现每个字符可以对应到的数值为何！要注意的是，该数值是 8 进位# 例如 S 对应的记录数值为 123 ，转成十进制：1x8^2+2x8+3=83。 修改文件时间或创建新文件：touch我们在 ls 这个指令的介绍时，有稍微提到每个文件在linux下面都会记录许多的时间参数， 其实有三个主要的变动时间，那么三个时间的意义是什么呢？ modification time （mtime） ： 当该文件的“内容数据”变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或权限喔！ status time （ctime） ： 当该文件的“状态 （status）”改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。 access time （atime） ： 当“该文件的内容被取用”时，就会更新这个读取时间（access） 。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的atime 了。 举例：查看 /etc/man_db.conf 这个文件的时间 12345[root@VM_0_26_centos ~]# date; ls -l /etc/man_db.conf ;ls -l --time=atime /etc/man_db.conf ; ls -l --time=ctime /etc/man_db.conf2016年 11月 12日 星期六 14:57:46 CST # 显示目前的时间-rw-r--r--. 1 root root 5171 6月 10 2014 /etc/man_db.conf # 创建内容的时间（mtime）-rw-r--r--. 1 root root 5171 6月 10 2014 /etc/man_db.conf # 读取内容的时间（atime）-rw-r--r--. 1 root root 5171 1月 20 2015 /etc/man_db.conf # 更新状态的时间（ctime） 默认情况下 ls 显示的是该文件的mtime，也就是这个文件内容上次被更改的时间。 文件的时间是很重要的，因为，如果文件的时间误判的话，可能会造成某些程序无法顺利的运行。 如果我们要修改文件时间则使用 touch 命令修改。 12345678910111213touch - 修改文件的时间戳记. touch [-acm][-r ref_file(参照文件)|-t time(时间值)] file(文件名)...OPTION: -a 修改文件 file 的存取时间，也就是仅修订 access time； -c 仅修改文件的时间，若该文件不存在则不创建新文件； -d, --date=time 后面可以接欲修订的日期而不用目前的日期，也可以使用 --date=&quot;日期或时间&quot; -m, --time=mtime, --time=modify 仅修改 mtime ； -t STAMP，decimtime 后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm] 12345678910111213141516171819202122232425262728293031323334范例一：新建一个空的文件并观察时间[xiangcl@VM_0_26_centos ~]$ cd /tmp/[xiangcl@VM_0_26_centos tmp]$ touch testtouch[xiangcl@VM_0_26_centos tmp]$ ls -l testtouch-rw-rw-r-- 1 xiangcl xiangcl 0 11月 14 09:13 testtouch# 新文件的大小为0。在默认状态下，如果 touch 后接有文件，则该文件的三个时间（atime/ctime/mtime）都会更新为目前的时间，若该文件不存在，则会主动的创建一个新的空文件。范例二：将 ~/.bashrc 复制为 bashrc ，复制完整的属性，并检查其日期。[xiangcl@VM_0_26_centos tmp]$ cp -a ~/.bashrc bashrc[xiangcl@VM_0_26_centos tmp]$ date; ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc2016年 11月 14日 星期一 09:21:02 CST # 这是当前的时间-rw-r--r-- 1 xiangcl xiangcl 231 8月 3 00:00 bashrc # 这是mtime的时间-rw-r--r-- 1 xiangcl xiangcl 231 8月 3 00:00 bashrc # 这是atime的时间-rw-r--r-- 1 xiangcl xiangcl 231 11月 14 09:20 bashrc # 这是ctime的时间# 在执行结果中，可以看到数据的内容与属性完全被复制过来，因此文件内容时间（mtime）与原本文件相同，但是由于这个文件是刚刚被创建的，因此状态（ ctime） 就变成现在的时间。范例三：修改范例二的 bashrc 文件，将日期（ctime）调整为两天前[xiangcl@VM_0_26_centos tmp]$ date; ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc;2016年 11月 14日 星期一 09:46:44 CST-rw-r--r-- 1 xiangcl xiangcl 231 11月 12 09:46 bashrc-rw-r--r-- 1 xiangcl xiangcl 231 11月 12 09:46 bashrc-rw-r--r-- 1 xiangcl xiangcl 231 11月 14 09:46 bashrc# （atime/ctime）变成了当前时间的 2 天以前，不过 ctime 并没有跟着改变。范例四：将上个范例的bashrc日期改为 2015/11/11 11:11[xiangcl@VM_0_26_centos tmp]$ touch -t 201511111111 bashrc[xiangcl@VM_0_26_centos tmp]$ date; ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc;2016年 11月 14日 星期一 09:50:25 CST-rw-r--r-- 1 xiangcl xiangcl 231 11月 11 2015 bashrc-rw-r--r-- 1 xiangcl xiangcl 231 11月 11 2015 bashrc-rw-r--r-- 1 xiangcl xiangcl 231 11月 14 09:50 bashrc# 时间atime和mtime都改变了，唯独ctime记录了当前的时间。 Note：1、即使我们复制一个文件时，复制所有的属性，但也没有办法复制ctime 这个属性的。 ctime 可以记录这个文件最近的状态 （ status） 被改变的时间。2、平时看的文件属性中，比较重要的还是属于那个 mtime touch 指令常用情景 创建一个空文件 修改文件时间（mtime和atime）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何把图片放在一个元素的上下居中？]]></title>
      <url>web-front-end%2Fimage-elements-center.html</url>
      <content type="text"><![CDATA[如何把图片放在一个元素的上下居中？实现效果： 代码：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;div放一个图片居中&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .div1{ width:250px; height:250px; border:1px solid red; display:table-cell; /*此元素会作为一个表格单元格显示*/ vertical-align:middle; /*把此元素放置在父元素的中部。*/ text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div1&quot;&gt; &lt;img src=&quot;ali.jpg&quot;&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[html+css定位相关知识点]]></title>
      <url>web-front-end%2Fhtml-css-location.html</url>
      <content type="text"><![CDATA[定位-基本概念 基本概念： css定位(Positioning)属性允许你对元素进行定位。（即把元素放在我们期望的位置） position属性值： static：静态定位，（默认值）。 relative：相对定位，设定元素的位置为相对其在父元素中的位置的一个相对位置。 absolute：设定元素的位置为一个绝对值所固定的位置，该绝对值是相对于此元素的上级具有非静态定位的元素而定的。如果其上级元素均没有非静态定位的情况，则相对于body(也就是整个网页)来定位。 fixed：非常类始于absolute定位，参照系是我们可见的窗口区域。即参照系并不是某个元素(也不是body网页)。 定位需要和四个值配合使用：left、top、right、button 案例相对定位(relative) 实现效果： 演示代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;相对定位&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .div-box{ width:400px; height:100px; border:1px solid red; } .div2{ width:80px; height:30px; float:left; background:green; margin:5px; } .te1{ /*向下移动50px*/ top:50px; /*向右移动30px*/ left:30px; /*使用相对定位*/ position:relative; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div-box&quot;&gt; &lt;div class=&quot;div2&quot;&gt;div1&lt;/div&gt; &lt;div class=&quot;div2 te1&quot;&gt;div2&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;div3&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;div4&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 案例结论： 相对定位的left和top是针对该元素原来的位置。 当相对定位后，原来的空间任是被保留的。 当相对定位后，如果相对定位后的元素和原来的元素有重叠，则会发生覆盖。 绝对定位(absolute) positon:absolute 绝对定位参考的点，是上一级最近的那个非静态定位元素的左上角定位。 如果上一级元素没有非静态定位的元素，则以浏览器视窗的左上角为原点。(body网页) 绝对定位后，他的空间会让给其它元素来使用。 实现效果： 演示代码：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;绝对定位&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .div-box{ width:400px; height:200px; border:1px solid red; position:absolute; } .div2{ width:80px; height:30px; background-color:blue; float:left; margin:5px; } .div1{ width:150px; height:60px; background-color:gray; float:left; position:absolute; top:100px; left:200px; } .te1{ width:80px; height:30px; background-color:blue; position:absolute; top:20px; left:30px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div-box&quot;&gt; &lt;div class=&quot;div2&quot;&gt;div1&lt;/div&gt; &lt;div class=&quot;div1&quot;&gt; &lt;div class=&quot;te1&quot;&gt;div2&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;div3&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;div4&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 静态定位 静态定位为默认定位方式 静态定位，对top、left、right、button都不生效。 fixed定位（固定定位） 元素框的表现类似于position，设置为absolute，不过其包含块是窗口本身。 实现效果： 代码：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;fixed定位&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .div1{ width:300px; height:300px; border:1px solid red; } .div2{ width:80px; height:50px; background-color:green; position:fixed; top:100px; left:100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div1&quot;&gt; hello world! &lt;br/&gt; hello world! &lt;br/&gt; hello world! &lt;br/&gt; hello world! &lt;br/&gt; &lt;div class=&quot;div2&quot;&gt;fixed定位&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 关于left和top居中显示的问题 问题：请思考，如何把一个div放在body的中间（左右和上下居中）？ 案例：实现效果： 代码演示：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;关于top和left居中的问题&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .juzhong{ position:absolute; width:300px; height:200px; background:blue; left:50%; margin-left:-150px; top:50%; margin-top:-100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;juzhong&quot;&gt;我想居中显示&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; z-index（可以理解为空间上下的定位）案例效果: 代码：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;z-index(空间定位)&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .div-box{ width:350px; height:200px; border:1px solid red; } .div-box img{ border:1px solid black; margin:5px; position:absolute; z-index:0; } .div-box span{ border:1px solid green; z-index:1; position:absolute; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div-box&quot;&gt; &lt;img src=&quot;ali.jpg&quot; &gt; &lt;span&gt;我是阿里。&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 小结： z-index和position:absolute配合使用 z-index默认值是0 z-index的值越大，越在上层]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建Hexo博客]]></title>
      <url>tool-config%2Fhexo-blog-build.html</url>
      <content type="text"><![CDATA[之前用wordpress做了一段时间的Bolg，后来才了解到Hexo。Hexo的好处就是配置灵活，简约而且轻巧，不会像wordpress那么一个庞然大物。所以干脆就将博客搬到了Hexo，而且还有免费的 github page 空间可以用。 搭建调试过程历经三天多。中间踩了很多坑，现一一记录下来，供诸君参考。 写到一半，中间有很多忘了，后面有空再补上吧。 准备工作服务器：使用的是腾讯云主机，一块钱一个月。大家如果有还在上大学的亲戚或朋友也可以借他们的学生身份。腾讯云学生优惠链接，腾讯云是可以创建子帐号的，所以大家不比担心帐号的问题。 软件：Centos 7.0 //云主机的系统 node v6.2.0 //运行环境 git 1.8.3.1 //必备软件 MarkdownPad 2 //md写作工具 Xhell 5 //linux的远程终端 FileZilla v3.21.0 //FTP软件 安装云主机很简单，自行解决。 Node环境Nodejs中文官网：http://nodejs.cn/ # sudo yum install gcc gcc-c++ //安装编译软件 # wget https://nodejs.org/dist/v6.2.0/node-v6.2.0.tar.gz //下载源码 # tar xzvf node-v6.2.0.tar.gz //解压源码 # cd node-v6.2.0/ //进入解压目录 # ./configure //编译&amp;&amp;安装 # make # make install # node -v //查看node版本 # npm -v //查看npm版本 安装Git$ sudo yum install git Hexo安装Hexo中文官网：https://hexo.io/zh-cn/（上面有详细教程） $ npm install -g hexo-cli 上面是官方的安装办法，我登了许久都没有反应，后来才知道可能是墙的原因。后来更换了淘宝npm镜像，安装方法： $ npm install -g cnpm --registry=https://registry.npm.taobao.org 因为更换了npm源所以在npm命令的前面都要加c,即为cnpm 再次安装Hexo： $ sudo cnpm install -g hexo-cli $ mkdir /home/blog $ cd /home/ $ hexo init blog $ cd blog $ cnpm install $ hexo server 经过上面的操作后，会在本地/home下新建一个/blog的目录，并在该文件夹下生成所需的文件。 默认产生的目录结构如下： . |-- _config.yml |-- db.json |-- debug.log |-- node_modules |-- package.json |-- public |-- scaffolds |-- source `-- themes 目录 描述 _config.yol 网站的配置信息 package.json 应用程序的信息 publice 执行hexo generate命令，输出的静态网页内容目录 scaffolds 模版文件夹 source 资源文件夹 themes 主题文件夹 基本命令hexo new &quot;postName&quot; #新建名为postName的文章 hexo new page &quot;pageName&quot; #新建名为pageName页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo clean #清楚缓存文件(`db.json`)和已生产的静态文件(public) hexo list &lt;type&gt; #列出网站资料 hexo version #显示hexo版本 配置基本的配置可以参考官网 先写这么多吧，后面的有点忘了，等有空补上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[武汉印象]]></title>
      <url>graphic-works%2Fgraphic-works-WuHanEffect.html</url>
      <content type="text"><![CDATA[武汉是一座我呆了一段时间的城市，每每回忆起来。总能有一种割舍不掉的情怀，只能以此怀念。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编辑器之神-VIM]]></title>
      <url>tool-config%2Fgod-editor-vim.html</url>
      <content type="text"><![CDATA[在这天地间，流传这两大神器的故事：据说Emacs是神的编辑器，而Vim是编辑器之神。正所谓，工欲善其事,必先利其器。今天就和大家分享一下关于编辑器之神Vim的传说。 一、Vim的历史1.下图是关于几款主流编辑器的学习曲线:(注：图片来自互联网) 2.VIM - Vi IMproved3.上图中vi即是vim的前身 VI：Visual Interface 4.VIM和VI是文本编辑器 何为文本文件？ 文本文件一般指只有字符原生编码构成的二进制计算机文件，与富文本相比，其不包含字样样式的控制元素，能够被最简单的文本编辑器直接读取 文本文件常见的格式？ ASCII、MIME、.txt、… 那么，何为文本编辑器？ 文本编辑器是计算机软件中的一种。主要用于用来编写和查看文本文件。 文本编辑器的种类： 行编辑器：sed 全屏编辑器：nano、vi、vim 二、Vim编辑器的基本操作1. 基本操作 VIM：模式化的编辑器 基本模式 编辑模式 （命令模式） 输入模式 （插入模式） 末行模式 （vim内置的命令行接口） Note：打开的时候默认的模式是编辑模式 打开文件 # vim [OPTION]... FILE... +#：打开文件后，直接让光标处于第#行的行首 +/PATTERN：打开文件后，直接让光标处于第一个被PATTERN匹配到的行的行首； 模式转换 模式转换： 编辑模式 - - &gt; 输入模式 i：insert，在光标所在处前面插入； a：append，在光标所在处的后面插入； o：open，在当前光标所在行的下一行打开新行，并转换为输入模式； I：在当前光标所在行的行首输入； A：在当前光标所在行的行尾输入； O：在光标所在行的上一行打开一个新行，并转换为输入模式； 输入模式 - - &gt; 编辑模式 ESC 编辑模式 - - &gt; 末行模式 ： 末行模式 - - &gt; 编辑模式 ESC 关闭文件 :q：退出 :!：强制退出，丢弃做出的修改； :wq：保存退出； :x：保存退出； :w /PATH/TO/SOMEWHERE：当前编辑的文本保存到别的文件； ZZ：保存退出； 图示说明如下： （转载请注明出处） 2. 光标跳转： 字符间跳转： h，j，k，l h：左 l：右 k：上 j：下 #COMMAND：跳转由#指定的个数的字符； 单词间跳转： w：跳转至下一个单词或后一个单词的词首； e：跳转至当前或下一个单词的词尾； b：跳转至当前或上一个单词的词首； #COMMAND：由#指定一次跳转的单词数； 行首行尾跳转： ^：跳转至行首的第一个非空白字符； 0：跳转至绝对的行首； $：跳转至绝对行尾； 行间移动： #G：跳转至由#指定行； G：跳转至最后一行； 1G，gg：跳转至第一行； 句间移动： )：跳转至下一个句子； (：跳转至上一个句子； 段落间移动： }：跳转至下一段 {：跳转至上一段 3. vim的编辑命令： 字符编辑： x：删除光标处的单个字符； #x：删除光标处起始的#个字符； xp：交换光标所在处的字符及其后面字符的位置； 替换命令： r，replace r：替换光标所在处的字符；（单字符替换） 删除命令： d：删除命令，可结合光标跳转字符，实现范围删除； d$：删除至绝对行尾 d^：删除至行首的第一个非空白字符 d0：删除至绝对行首 dd：删除光标所在行； #dd：向下删除#行； 粘贴命令： （p，put，paste） p：缓冲区中存储的如果为整行内容，则粘贴至当前光标所在行的下方；否则，则粘贴至当前光标所在处的后面； P：缓冲区中存储的如果为整行内容，则粘贴至当前光标所在行的上方；否则，则粘贴至当前光标所在处的前面； 复制命令： y，yank y：复制，工作行行为相似于d命令； y$：复制至绝对行尾 y0：复制至绝对行首 y^：复制至行首的第一个非空白字符 yy：复制整行 #yy：复制多行； 改变命令： c，change c：修改 编辑模式 - -&gt; 输入模式 cc：删除并输入新内容 #cc：一次删除#行 三、其它编辑操作1.可视化模式 v：按字符选定 V：按行选定 Note：经常结合编辑命令； 2. 撤销此前的编辑： u(undo)：撤销此前的操作； #u：撤销指定次数的操作； 撤销此前的撤销： Ctrl+r 重复前一个编辑操作： . 四、翻屏操作 Ctrl+f：向文件尾部翻一屏； Ctrl+b：向文件首部翻一屏； Ctrl+d：向文件尾部翻半屏； Ctrl+u：向文件首部翻半屏； vim自带的练习教程： vimtutor 五、vim的末行模式 内建的命令行接口； 特性： (1). 地址定界 ：start_pos,end_pos #：具体的第#行，例如：2表示第2行； #，#：从左侧#表示起始，到右侧#表示结束； #,+#：从左侧#表示的行开始，加上右侧#表示的行数； .当前行； $：最后一行； %：全文；相当于（1,$） /pat1/,/pat2/：表示从第一次被pat1匹配到的行开始，一直到pat2匹配到的行结束 使用方式： 后跟一个编辑命令： d：删除指定范围的内容 y：复制指定范围的内容 w /PATH/TO/SOMEWHERE：将范围内的行另存至指定文件中； r /PATH/FROM/SOMEFILE：在指定位置插入指定文件中的所有内容； (2). 查找 /PATTERN：从当前光标所在处向文件尾部查找 ?PATTERN：从当前光标所在处向文件首部查找 n：与命令同方向； N：与命令反方向； (3). 查找并替换 s：在末行模式下完成查找替换操作 s/要查找的内容/替换为的内容/修饰符 要查找的内容：可使用模式； 替换为的内容：不能使用模式，但可以使用\1, \2, …等后向引用符号；好可以使用&quot;&amp;&quot;引用前面查找时查找到的整个内容； 修饰符： i：忽略大小写 g：全局替换;默认情况下，没一行只替换第一次出现的内容； 查找替换中的分隔符/可替换为其它字符，例如： s@@@ s### 六、vim的文件模式1. 多文件模式 vim FILE1 FILE2 FILE3 … :next 切换至下一个文本 :prev 切换至前一个文本 :first 切换至前一个文本 :last 切换至最后一个文本 :wall 保存所有 :qall 退出所有 2. 窗口分隔模式 vim -o|-O FILE1 FILE2 … -o：水平分割 -O：垂直分割 在窗口间切换：Ctrl+w，Arrow 3. 单文件窗口分割： Ctrl+w，s：split，水平分割 Ctrl+w，v：vertical，垂直分割 4. 定制vim的工作特性：（部分） 配置文件：（永久有效） 全局：/etc/vimrc 个人：~/.vimrc (默认不存在，需要自己创建) 末行：（当前vim进程有效） (1) 行号： 显示：set number，简写为：set nu 取消显示：set nonumber，简写为：set nonu (2) 括号匹配： 匹配：set showmatch，简写为：set sm 取消匹配：set nosm (3) 自动缩进： 开启：set ai 禁用：set noai (4) 高亮搜索 开启：set hlsearch 禁用：set nohlsearch (5) 语法高亮 开启：syntax on 禁用：syntax off (6) 忽略字符大小写 启用：set ic 禁用：set noic 5. 书籍推荐：《Vim-handbook-cn-72》6. 获取帮助 在末行模式下：help SUBJECT]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux文件与目录管理2]]></title>
      <url>Linux%2Flinux-file-dir-man-two.html</url>
      <content type="text"><![CDATA[文件和目录的默认权限与隐藏权限文件默认权限： umaskumask：指定目前使用者在创建文件或目录时的权限默认值。 1234567891011[xiangcl@centos-rpi3 ~]$ umask0002 # 与一般权限有关是后三位数字[xiangcl@centos-rpi3 ~]$ umask -Su=rwx,g=rwx,o=rx[xiangcl@centos-rpi3 ~]$ su -密码：上一次登录：一 11月 14 05:53:08 UTC 2016pts/0 上[root@centos-rpi3 ~]# umask0022 # 基于安全的考量， root默认的是022[root@centos-rpi3 ~]# umask -Su=rwx,g=rx,o=rx Note：umask的第一组数字是特殊权限使用。 在默认权限的属性上，目录与文件是不一样的。x 权限对于目录是非常重要的！ 但是一般文件的创建则不应该有执行的权限，因为一般文件通常是用在于数据的记录嘛！当然不需要执行的权限了。 因此，默认的情况如下： 若使用者创建为“文件”则默认“没有可执行（x ） 权限”，亦即只有 rw 这两个项目，也就是最大为 666 分，默认权限如下： -rw-rw-rw- 若使用者创建为“目录”，则由于 x 与是否可以进入此目录有关，因此默认为所有权限均开放，亦即为 777 分，默认权限如下： drwxrwxrwx 因为 umask 为 022 ，所以 user 并没有被拿掉任何权限，不过 group 与 others 的权限被拿掉了 2 （ 也就是 w 这个权限） ，那么当使用者： 创建文件时：（ -rw-rw-rw-） - （ —–w–w-） ==&gt; -rw-r–r– 创建目录时：（ drwxrwxrwx） - （ d—-w–w-） ==&gt; drwxr-xr-x 1234567[root@centos-rpi3 ~]# umask0022[root@centos-rpi3 ~]# touch test1[root@centos-rpi3 ~]# mkdir test2[root@centos-rpi3 ~]# ll -d test*-rw-r--r--. 1 root root 0 11月 14 06:04 test1drwxr-xr-x. 2 root root 4096 11月 14 06:04 test2 123456789umask # : 设定范例一：修改默认的 umask 的值[root@centos-rpi3 ~]# umask 002[root@centos-rpi3 ~]# touch test3[root@centos-rpi3 ~]# mkdir test4[root@centos-rpi3 ~]# ll -d test[34]-rw-rw-r--. 1 root root 0 11月 14 06:10 test3drwxrwxr-x. 2 root root 4096 11月 14 06:10 test4 Note： umask对于新建文件与目录的默认权限是很重要的 12345678910111213141516171819例题：假设你的 umask 为003，请问该 umask 情况下，创建的文件和目录的权限为？umask 为 003所以拿掉的权限为：--------wx文件：-rw-rw-rw----------wx=-rw-rw-r--目录：drwxrwxrwx-d-------wx=drwxrwxr-- 文件隐藏属性下面的 chattr 指令只能在Ext2/Ext3/Ext4 的Linux传统文件系统上面完整的生效，其它文件系统不能完整支持。 chattr （设置文件隐藏属性）1234567891011121314151617181920212223 chattr [ -RV ] [ -v version ] [ mode ] files...OPTION：选项与参数：+ ：增加某一个特殊参数，其他原本存在参数则不动。- ：移除某一个特殊参数，其他原本存在参数则不动。= ：设置一定，且仅有后面接的参数A ：当设置了 A 这个属性时，若你有存取此文件（ 或目录） 时，他的存取时间 atime 将不会被修改，可避免 I/O 较慢的机器过度的存取磁盘。（ 目前建议使用文件系统挂载参数处理这个项目）S ：一般文件是非同步写入磁盘的（ 原理请参考[前一章sync](../Text/index.html#sync)的说明） ，如果加上 S 这个属性时，当你进行任何文件的修改，该更动会“同步”写入磁盘中。a ：当设置 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root 才能设置这属性c ：这个属性设置之后，将会自动的将此文件“压缩”，在读取的时候将会自动解压缩，但是在储存的时候，将会先进行压缩后再储存（ 看来对于大文件似乎蛮有用的！）d ：当 dump 程序被执行的时候，设置 d 属性将可使该文件（ 或目录） 不会被 dump 备份i ：这个 i 可就很厉害了！他可以让一个文件“不能被删除、改名、设置链接也无法写入或新增数据！”对于系统安全性有相当大的助益！只有 root 能设置此属性s ：当文件设置了 s 属性时，如果这个文件被删除，他将会被完全的移除出这个硬盘空间，所以如果误删了，完全无法救回来了喔！u ：与 s 相反的，当使用 u 来设置文件时，如果该文件被删除了，则数据内容其实还存在磁盘中，可以使用来救援该文件喔！注意1：属性设置常见的是 a 与 i 的设置值，而且很多设置值必须要身为 root 才能设置注意2：xfs 文件系统仅支持 AadiS 而已 1234567891011121314范例一：尝试在 /tmp 下创建文件，并加入 i 的参数，然后删除看看[root@centos-rpi3 ~]# cd /tmp/[root@centos-rpi3 tmp]# ls[root@centos-rpi3 tmp]# touch attrtest[root@centos-rpi3 tmp]# chattr +i attrtest[root@centos-rpi3 tmp]# rm attrtestrm：是否删除普通空文件 &quot;attrtest&quot;？yrm: 无法删除&quot;attrtest&quot;: 不允许的操作# 是不是无法删除？# 取消 -i 属性又能删除了[root@centos-rpi3 tmp]# chattr -i attrtest[root@centos-rpi3 tmp]# rm attrtestrm：是否删除普通空文件 &quot;attrtest&quot;？y lsattr （显示文件隐藏属性）123456789lsattr [ -RVadv ] [ files... ]OPTION:-a ：将隐藏文件的属性也秀出来；-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；-R ：连同子目录的数据也一并列出来！[root@centos-rpi3 tmp]# chattr +aiS attrtest[root@centos-rpi3 tmp]# lsattr attrtest--S-ia-------e-- attrtest 文件特殊权限：SUID，SGIG, SBIT123[root@centos-rpi3 tmp]# ls -ld /tmp; ls -l /usr/bin/passwddrwxrwxrwt. 7 root root 4096 11月 14 06:38 /tmp-rwsr-xr-x. 1 root root 27236 5月 23 2015 /usr/bin/passwd 权限里竟然冒出了 t 和 s。 Set UID当 s 这个标志出现在文件拥有者的 x 权限上时，例如刚刚提到的 /usr/bin/passwd 这个文件的权限状态：“-rwsr-xr-x”，此时就被称为 Set UID，简称为 SUID 的特殊权限。 那么SUID的权限对于一个文件的特殊功能是什么呢？基本上SUID有这样的限制与功能： SUID 权限仅对二进制程序（ binary program） 有效； 执行者对于该程序需要具有 x 的可执行权限； 本权限仅在执行该程序的过程中有效 （ run-time） ； 执行者将具有该程序拥有者 （ owner） 的权限。 例：我们的 Linux 系统中，所有帐号的密码都记录在 /etc/shadow 这个文件里面，这个文件的权限为：“———- 1 root root”，意思是这个文件仅有root可读且仅有root可以强制写入而已。既然这个文件仅有 root 可以修改，那么自己的帐号这种一般帐号使用者能否自行修改自己的密码呢？ 你可以使用你自己的帐号输入“passwd”这个指令来看看。一般使用者当然可以修改自己的密码了！ SUID对目录无效 Set GID默认情况下，用户创建文件时，其属组为此用户所属的基本组； 一旦某目录被设定了SGID，则对此目录有写权限的用户在此目录中创建的文件所属的组为此目录的属组； 权限设定：12chmod g+s DIR...chmod g-s DIR... 对文件来说，SGID有如下功能： SGID 对二进制程序有用； 程序执行者对于该程序来说，需具备 x 的权限； 执行者在执行的过程中将会获得该程序群组的支持！ 对目录来说，SGID有如下功能： 使用者若对于此目录具有 r 与 x 的权限时，该使用者能够进入此目录； 使用者在此目录下的有效群组（ effective group） 将会变成该目录的群组； 用途：若使用者在此目录下具有 w 的权限（ 可以新建文件） ，则使用者所创建的新文件，该新文件的群组与此目录的群组相同。 StickySBIT 目前只针对目录有效，对于文件已经没有效果了。SBIT 对于目录的作用是： 当使用者对于此目录具有 w, x 权限，亦即具有写入的权限时； 当使用者在该目录下创建文件或目录时，仅有自己与 root 才有权力删除该文件 对于一个多人可写的目录，如果设置了sticky，则每个用户仅能删除自己的文件； 1234567891011121314151617181920212223242526权限设定： chmod o+t DIR... chmod o-t DIR...SUID SGID STICKY 000 0 001 1 010 2 011 3 100 4 101 5 110 6 111 7 chmod 4777 /tmp/a.txt几个权限位映射： SUID: user, 占据属主的执行权限位； s: 属主拥有x权限 S：属主没有x权限 SGID: group, 占据group的执行权限位； s: group拥有x权限 S：group没有x权限 Sticky: other, 占据ohter的执行权限位； t: other拥有x权限 T：other没有x权限 指令与文件的搜索指令文件名的搜索在终端机模式当中，连续输入两次[tab]按键就能够知道使用者有多少指令可以下达。那你知不知道这些指令的完整文件名放在哪里？ which （搜索“可执行文件”）1234567891011121314151617181920212223which [options] [--] programname [...]OPTIONS:-a, --all 将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称--skip-alias: 禁止显示别名范例一：搜索 ifconfig 这个指令的完整文件名[root@centos-rpi3 tmp]# which ifconfig/sbin/ifconfig范例二：用 which 去找出 which 的文件名[root@centos-rpi3 tmp]# which whichalias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos; /bin/alias /usr/bin/which# alias 是命令别名范例三：请找出 history 这个指令的完整文件名[root@centos-rpi3 tmp]# which history/usr/bin/which: no history in (/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin)# history是“bash内置的指令”，但是 which 默认是找 PATH 内所规范的目录。所以当然搜寻不到 这个命令是根据 “PATH” 这个环境变量所规范的路径，去搜索“可执行文件”的文件名。 文件、文件名的搜索搜索文件时 find 不很常用，因为速度慢之外，也很损耗硬盘。一般我们都是先使用whereis 或者是 locate 来检查，如果真的找不到了，才以 find 来搜寻。whereis 只找系统中某些特定目录下面的文件而已，locate 则是利用数据库来搜寻文件名，当然两者就相当的快速， 并且没有实际的搜寻硬盘内的文件系统状态，比较省时间。 whereis （由一些特定的目录中寻找文件、文件名）1234567891011121314151617whereis [options] [-BMS directory... -f] name...OPTION:-l :可以列出 whereis 会去查询的几个主要目录而已-b :只找 binary 格式的文件-m :只找在说明文档 manual 路径下的文件-s :只找 source 来源文件-u :搜寻不在上述三个项目当中的其他特殊文件范例一：请找出 ifconfig 这个文件名[root@centos-rpi3 tmp]# whereis ifconfigifconfig: /usr/sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz范例二：只找出跟 passwd 有关的“说明文档”文件名 （man page）[root@centos-rpi3 tmp]# whereis passwd # 列出全部的文件名passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz[root@centos-rpi3 tmp]# whereis -m passwd # 只有在 man 里面的文件名才列出来passwd: /usr/share/man/man1/passwd.1.gz whereis 主要是针对 /bin /sbin 下面的可执行文件， 以及 /usr/share/man 下面的 man page 文件，跟几个比较特定的目录来处理 要知道 whereis 到底查了多少目录？可以使用 whereis -l 来查看。 locate / updatedb123456789101112131415locate - 按名称查找文件 locate [OPTION]... PATTERN...OPTION：-i，--ignore-case 忽略大小写的差异；-c，--count 不输出文件名，仅计算找到的文件数量-l， --limit, -n LIMIT 仅输出几行的意思，例如输出五行则是 -l 5-S，, --statistics 输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等-r，--regexp REGEXP 后面可接正则表达式的显示方式 123456789101112131415范例一：找出系统中所有与 passwd 相关的文件名，且只列出5个[xiangcl@VM_0_26_centos ~]$ locate -l 5 passwd/etc/passwd/etc/passwd-/etc/pam.d/passwd/etc/security/opasswd/root/node-v6.2.0/deps/openssl/openssl/apps/passwd.c范例二：列出 locate 查询所使用的数据库文件之文件名与各数据数量[xiangcl@VM_0_26_centos ~]$ locate -S数据库 /var/lib/mlocate/mlocate.db: 18,507 文件夹 # 总记录目录数 120,727 文件 # 总记录文件数 7,442,050 文件名中的字节数 2,959,140 字节用于存储数据库 忘记某个文件的完整文件名时，可以使用locate locate 寻找的数据是由“已创建的数据库 /var/lib/mlocate/” 里面的数据所搜寻到的，所以不用直接在去硬盘当中存取数据 使用locate会有限制，因为他是经由数据库来搜寻的，而数据库的创建默认是在每天执行一次 （ 每个 distribution 都不同，CentOS 7.x 是每天更新数据库一次！） ，所以当你新创建起来的文件， 却还在数据库更新之前搜寻该文件，那么 locate 会告诉你“找不到！”。因为必须更新数据库 更新 locate 数据库的方法非常简单，直接输入“updatedb ”就可以了！ updatedb 指令会去读取 /etc/updatedb.conf 这个配置文件的设置，然后再去硬盘里面进行搜寻文件名的动作， 最后就更新整个数据库文件啰！因为 updatedb 会去搜寻硬盘，所以当你执行 updatedb 时，可能会等待数分钟的时间喔！ 执行步骤 updatedb：根据 /etc/updatedb.conf 的设置去搜寻系统硬盘内的文件名，并更新/var/lib/mlocate 内的数据库文件； locate：依据 /var/lib/mlocate 内的数据库记载，找出使用者输入的关键字文件名。 find (递归地在层次目录中处理文件)概述：实事查找工具，通过便利指定路径下的文件系统完成文件查找 特点： 查找速度略慢 精确查找 实事查找 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495find [OPTION]... [查找路径] [查找条件] [处理动作] 查找路径： 指定具体目标路径；默认为当前目录； 查找条件： 指定的查找标准，可以文件名、大小、类型、权限等标准进行；默认为找出指定路径下的所有文件； 处理动作： 对符合条件的文件做什么操作；默认输出至屏幕；查找条件： 根据文件名查找： -name “文件名” -iname “文件名”：不区分字母大小写 -regex &quot;PATTERN&quot;：以PATTERN（文件名与正则表达式）匹配整个文件路径字符串，而不仅仅是文件名称； 根据属主、属组查找： -user USERNAME：查找属主为指定用户的文件； -group GRPNAME: 查找属组为指定组的文件； -uid UserID：查找属主为指定的UID号的文件； -gid GroupID：查找属组为指定的GID号的文件； -nouser：查找没有属主的文件； -nogroup：查找没有属组的文件； 根据文件类型查找： -type TYPE: f: 普通文件 d: 目录文件 l: 符号链接文件 s：套接字文件 b: 块设备文件 c: 字符设备文件 p: 管道文件 组合条件： 与：-a 或：-o 非：-not, ! !A -a !B = !(A -o B) !A -o !B = !(A -a B) 范例：找出/tmp目录下，属主不是root，且文件名不是fstab的文件； find /tmp \( -not -user root -a -not -name &apos;fstab&apos; \) -ls find /tmp -not \( -user root -o -name &apos;fstab&apos; \) -ls # 加上 -ls ，是查找并显示结果 根据文件大小来查找：(示意图如下：find指令文件大小范围示意图) -size [+|-]#UNIT 常用单位：k, M, G #UNIT: (#-1, #] -#UNIT：[0,#-1] +#UNIT：(#,oo) 根据时间戳：(示意图如下：find指令时间戳范围示意图) 以“天”为单位； -atime [+|-]#, #: [#,#+1) +#: [#+1,oo] -#: [0,#) -mtime -ctime 以“分钟”为单位： -amin -mmin -cmin 根据权限查找： -perm [/|-]MODE MODE: 精确权限匹配 /MODE：任何一类(u,g,o)对象的权限中只要能一位匹配即可； -MODE：每一类对象都必须同时拥有为其指定的权限标准；处理动作： -print：默认的处理动作，显示至屏幕； -ls：类似于对查找到的文件执行“ls -l”命令； -delete：删除查找到的文件； -fls /path/to/somefile：查找到的所有文件的长格式信息保存至指定文件中； -ok COMMAND &#123;&#125; \; 对查找到的每个文件执行由COMMAND指定的命令； 对于每个文件执行命令之前，都会交互式要求用户确认； -exec COMMAND &#123;&#125; \; 对查找到的每个文件执行由COMMAND指定的命令; &#123;&#125;: 用于引用查找到的文件名称自身； 注意：find传递查找到的文件至后面指定的命令时，查找到所有符合条件的文件一次性传递给后面的命令； 有些命令不能接受过多参数，此时命令执行可能会失败；另一种方式可规避此问题： find | xargs COMMAND范例一：将过去系统上24小时内有更动过内容（mtime）的文件列出[root@centos-rpi3 ~]# find / -mtime 0# 那个 0 是重点！0 代表目前的时间，所以，从现在开始到 24 小时前，# 有变动过内容的文件都会被列出来！那如果是三天前呢？# find / -mtime 3 有变动过的文件都被列出的意思！范例二：寻找 /etc 下面的文件，如果文件日期比 /etc/passwd 新就列出[root@centos-rpi3 ~]# find /etc -newer /etc/passwd# -newer 用在分辨两个文件之间的新旧关系是很有用的。 find指令文件大小范围示意图 find指令时间戳范围示意图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[yum:CentOS包管理工具]]></title>
      <url>tool-config%2Fyum-centos-package-tool.html</url>
      <content type="text"><![CDATA[##Linux系统的包管理工具 优点1.自动处理依赖性关系 2.简化安装过程 包管理器的分类 CentOS yum Ubuntu apt yum语法yum [options] [command] [package ...] options-h：显示帮助信息； -e 静默执行 -t 忽略错误 -R[分钟] 设置等待时间 -y 自动应答yes command清除yum缓存$ yum check #检查 RPM 数据库问题 $ yum check-update #检查是否有可用的软件包更新 $ yum clean packages #清除临时包文件（/var/cache/yum 下文件） $ yum clean headers #清除rpm头文件 $ yum clean all #清除全部 搜索与检查要安装的包$ yum search php #搜索和php相关的包 $ yum info php-common #查看`php-common`这个包的具体的信息 $ yum deplist php-common #查看`php-common`的依赖 $ yum search all php #加上了包的详细描述 yum info php-common yum deplist php-common 安装包$ sudo yum install php-cli #安装`php-cli` Is this ok [y/d/N]: y 或者: 如果确定要安装这个包后，直接使用: $ sudo yum install php-cli -y #不用确认直接安装 $ php --help #若出现php的相关帮助信息就证明安装成功 升级包$ yum check-update #检测可升级的包 $ sudo yum install #更新所有的包 $ sudo yum upgrade python #升级python这个包 删除包$ yum list installed #查看系统当前都安装了哪些包 $ yum list installed | grep php #仅仅显示和php相关的包 $ sudo yum remove php-common #删除php-common这个包 $ yum list installed | grep php #再次搜索与php相关的包 sudo yum remove php-common 仓库$ yum repolist #列出系统启用的仓库列表 $ yum search epel #搜索和`epel`相关的包 $ sudo yum epel-release -y #安装`epel-release` $ yum repolist #列出仓库列表 $ yum list available #查看所有可用的包 $ sudo yum install https://centos7.iuscommunity.org/ius-release.rpm #直接指定地址安装`ius`仓库的包 $ yum list available | grep php #列出所有和php相关的包 $ yum info php70u-common #查看`php70u-common`包的详细信息 yum repolist yum search epel 主要介绍了CentOS下yum的包管理方式，以及一些yum常用的命令。因为主要使用的CentOS系统。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux数据库备份]]></title>
      <url>linux%2Flinux-database-backup.html</url>
      <content type="text"><![CDATA[目标: 每隔1分钟,导出.sql,压缩,并按日期存储在/data 下,每分钟后删除.sql文件,每隔2分钟删除.tar.gz文件知识: 定时任务 crontab , mysqldump 导出 , tar 打包压缩, 按日期创建文件 date准备部分1.建立mysqldump软链接(必须在~目录下建立软链接) ln -s /usr/local/mysql/bin/mysqldump /usr/bin/mysqldump 2.将mysql.bak.sql导出备份到~目录下 mysqldump -uroot -p123 -B mysql &gt; ./mysql.bak.sql 3.将导出的mysql.bak.sql打包成.tar.gz tar zcvf mysql.bak.sql.tar.gz mysql.bak.sql 正式写shell脚本1.新建bak.sh脚本文件 vim bak.sh 往脚本里写的内容: #!/bin/bash cd /data rm -f *.sql old=`date -d &apos;-2 minute&apos; +%Y%m%d%H%M` tad=`date +%Y%m%d%H%M` /usr/local/mysql/bin/mysqldump -uroot -p123 -B mysql &gt; ./$tad.sql tar zcf $tad.sql.tar.gz $tad.sql # -f是判断文件是否存在 if [ -f /data/$old.sql.tar.gz ] then rm -rf /data/$old.sql.tar.gz fi 2.在/目录下创建一个data目录 mkdir -p /data/ 3.创建定时任务: crontab -e 4:编辑定时任务: */1 * * * * /data/bak.sh]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML+CSS之盒模型经典布局]]></title>
      <url>web-front-end%2Fhtml-css-box-model.html</url>
      <content type="text"><![CDATA[css核心内容——流标准流/非标准流 流：在现实生活中就是流水，在网页设计中就是指元素（标签）的排列方式（默认情况下，我们的元素，向网页的左上角流动）； 标准流：元素在网页中就像流水，排在前面的元素（标签）内容在前面出现，排在后面的元素在后面出现。 非标准流：当某个标签脱离了标准流（比如因为相对定位）排列，我们统称为非标准流排列。 css核心类容——盒子模型盒子模型-概念 要搞清楚盒子模型就必须先明白下面几个概念： 在网页设计中常听到的属性名：内容（content）、填充（padding）、边框（border）、边界（margin），css盒子模型都举杯这些属性。 盒子模型经典案例1： 实际效果： 代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;盒子模型&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #div-box1 { width:200px; height:200px; background-color:pink; border:1px solid red; margin-top:10px; margin-left:20px; padding-top:20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div-box1&quot;&gt;hello,world!&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 对应的盒子大概的样子： 盒子模型的经典案例2： 实际效果： 代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;盒子模型经典案例-优酷牛人&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *{ margin: 0; padding:0; } #div-box1{ width:600px; height:500px; border:1px solid #ccc; margin:20px 0 0 50px; } .faceul{ list-style-type:none; } .faceul li{ width:80px; height:100px; border:1px solid red; margin:10px 0 0 10px; float:left; } .faceul img{ width:70px; margin:5px 0 0 5px; } .faceul span{ font-size:small; margin: 2px 0 0 25px; display:block; } .faceul a:link{ color:black; text-decoration:none; } .faceul a:hover{ color:red; text-decoration:underline; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div-box1&quot;&gt; &lt;ul class=&quot;faceul&quot;&gt; &lt;li&gt;&lt;img src=&quot;ali.jpg&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot;&gt;阿狸&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;ali.jpg&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot;&gt;阿狸&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;ali.jpg&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot;&gt;阿狸&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;ali.jpg&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot;&gt;阿狸&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;ali.jpg&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot;&gt;阿狸&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;ali.jpg&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot;&gt;阿狸&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;ali.jpg&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot;&gt;阿狸&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;ali.jpg&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot;&gt;阿狸&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;ali.jpg&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot;&gt;阿狸&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;ali.jpg&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot;&gt;阿狸&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;ali.jpg&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot;&gt;阿狸&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
    </entry>

    
  
  
</search>
